# -*- coding: utf-8 -*-
"""game.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w-Daw45QBFFF2BfKQE6YHwTHcWznoJXm
"""

# ===================== 4×4×4 立体四目・ビットボード版（命名統一） =====================
from __future__ import annotations
from dataclasses import dataclass
from typing import List
import random, math
import numpy as np


SIZE        = 4
BOARD_SIZE  = SIZE ** 3                 # 64
ALL_MASK    = (1 << BOARD_SIZE) - 1     # 0xffff_ffff_ffff_ffff

# --- 3D → 1D インデックスとビット -----------------
def idx(x: int, y: int, z: int) -> int: return x + y*SIZE + z*SIZE*SIZE
def BIT(x: int, y: int, z: int) -> int: return 1 << idx(x, y, z)

# --- 76 本の勝利ライン --------------------------------
def make_lines76() -> List[int]:
    r, L = range(SIZE), []
    # 軸方向
    for y in r:
        for z in r: L.append(sum(BIT(x,y,z) for x in r))
    for x in r:
        for z in r: L.append(sum(BIT(x,y,z) for y in r))
    for x in r:
        for y in r: L.append(sum(BIT(x,y,z) for z in r))
    # 平面斜め
    for z in r:
        L += [sum(BIT(i,i,z)          for i in r),
              sum(BIT(SIZE-1-i,i,z)   for i in r)]
    for y in r:
        L += [sum(BIT(i,y,i)          for i in r),
              sum(BIT(SIZE-1-i,y,i)   for i in r)]
    for x in r:
        L += [sum(BIT(x,i,i)          for i in r),
              sum(BIT(x,SIZE-1-i,i)   for i in r)]
    # 空間斜め
    L += [sum(BIT(i,i,i)              for i in r),
          sum(BIT(SIZE-1-i,i,i)       for i in r),
          sum(BIT(i,SIZE-1-i,i)       for i in r),
          sum(BIT(SIZE-1-i,SIZE-1-i,i)for i in r)]
    assert len(L) == 76
    return L

LINES76 = make_lines76()

# -- 決勝点 (三連＋空) -------------------------------------------------
def ketsu_bits(my:int, opp:int)->int:
    occ, k = my|opp, 0
    for line in LINES76:
        if line & opp: continue
        if (line & my).bit_count()==3:
            k |= line & ~occ            # 空 1 マスを追加
    return k

# -- DR-2 プレーン生成（高さ連続） -------------------------------------
def dr2_plane(my:int, opp:int)->np.ndarray:
    """
    4×4 bool 行列。セル (x,y) が DR-2 決勝点なら True
    """
    k = ketsu_bits(my, opp)
    mask = np.zeros((SIZE,SIZE), bool)

    for col in COL_MASKS:                     # 16 列
        col_k = k & col
        if not col_k: continue
        # 高さ集合と隣接ペア検出
        zs = [(idx)//16 for idx in range(64) if col_k>>idx & 1]
        zs.sort()
        has_pair = any(z2==z1+1 for z1,z2 in zip(zs,zs[1:]))
        if not has_pair: continue             # 非連続 → 無視

        # 当該列の決勝点セルをマーク
        for idx in range(64):
            if col_k>>idx & 1:
                x,y,z = idx%4, (idx//4)%4, idx//16
                mask[y,x] = True              # 4×4 board 上 (row,col)

    return mask

# -- Even/Odd 決勝点プレーン -------------------------------------------
def ketsu_even_odd_filtered(my: int, opp: int) -> tuple[np.ndarray, np.ndarray]:
    """
    偶数段 / 奇数段 決勝点プレーンを返す (4×4 bool)。
    ただしセル (x,y,z) は
        ・そのセル自体が決勝点
        ・かつ z==0  もしくは  真下 (z-1) が **敵の決勝点ではない**
    場合のみ 1 とする。
    """
    k_my  = ketsu_bits(my,  opp)
    k_opp = ketsu_bits(opp, my)

    even = np.zeros((SIZE, SIZE), dtype=bool)
    odd  = np.zeros((SIZE, SIZE), dtype=bool)

    for idx in range(64):
        bit = 1 << idx
        if not ( (k_my | k_opp) & bit ):
            continue                     # 決勝点でない

        x, y, z = idx % 4, (idx // 4) % 4, idx // 16

        # --- “真下が敵決勝点ではない” フィルタ ----------------
        if z > 0:
            below = 1 << (idx - 16)
            # 自分の決勝点の場合: 下が相手決勝点なら無効
            if (k_my & bit)  and (k_opp & below):
                continue
            # 相手の決勝点の場合: 下が自分決勝点なら無効
            if (k_opp & bit) and (k_my  & below):
                continue
        # z == 0 は常に OK

        # 偶奇チャネルへ書き込み
        (even if z % 2 == 0 else odd)[y, x] = True
    return even, odd

# ── 4×4 平面の 10 本ライン (行 4 + 列 4 + 斜め 2) の 16-bit マスク ──
PLANE_MASKS = [
    0b0001_0001_0001_0001, 0b0010_0010_0010_0010, 0b0100_0100_0100_0100, 0b1000_1000_1000_1000,  # 列
    0b1111_0000_0000_0000, 0b0000_1111_0000_0000, 0b0000_0000_1111_0000, 0b0000_0000_0000_1111,  # 行
    0b1000_0100_0010_0001, 0b0001_0010_0100_1000                                        # 斜め
]

def drp_plane(my: int, opp: int) -> np.ndarray:
    """
    自分側の **同一平面ダブルリーチ** を 4×4 bool 行列で返す。
    条件：同じ高さ z に **自分の決勝点セルが 2 個以上**。
    """
    k_my = ketsu_bits(my, opp)            # 64-bit 決勝点
    mask = np.zeros((4, 4), dtype=bool)

    for z in range(4):
        plane = (k_my >> (16 * z)) & 0xFFFF  # 16-bit
        if plane.bit_count() < 2:
            continue                        # 決勝点が 1 個以下

        # 2 本以上のラインに分散しているか判定
        line_cnt = sum(1 for m in PLANE_MASKS if (plane & m))
        if line_cnt < 2:
            continue

        # 該当セルをマーク
        for idx in range(16):
            if plane >> idx & 1:
                x, y = idx % 4, idx // 4
                mask[y, x] = True
    return mask


COL_MASKS = [
    sum(BIT(x, y, z) for z in range(SIZE))
    for y in range(SIZE) for x in range(SIZE)
]   # 16 列の 64bit マスク

def collect_threats(my:int, opp:int)->List[int]:
    occ,out = my|opp,[]
    for line in LINES76:
        if line & opp or (line & my).bit_count()!=3: continue
        empty = line & ~occ
        if empty:
            i = empty.bit_length()-1
            z = i//16
            if z==0 or (occ>>(i-16) & 1):
                out.append(i)
    return list(set(out))

def collect_pre_threats(my:int, opp:int)->list[int]:
    """
    自石が 2 個 / 相手石 0 / 空 2 で、
    打てば『三連＋空1』になる“準脅威セル”を返す。
    """
    occ, out = my|opp, []
    for line in LINES76:
        if line & opp: continue
        if (line & my).bit_count() != 2:   # ★二連
            continue
        empties = line & ~occ
        # 空マス 2 つのうち「今すぐ置ける」方だけ追加
        while empties:
            b   = empties & -empties
            idx = b.bit_length()-1
            z   = idx//16
            if z==0 or (occ>>(idx-16) & 1):   # 重力OK
                out.append(idx)
            empties ^= b
    return list(set(dict.fromkeys(out)))

def collect_float_pre_threats(my:int, opp:int)->List[int]:
    occ,out = my|opp,[]
    k = 0
    for line in LINES76:
        if line & opp or (line & my).bit_count()!=3: continue
        k |= line & ~occ
    while k:
        b = k & -k
        top = b.bit_length()-1
        z   = top//16
        k  ^= b
        if z==0: continue
        below = top-16
        if (occ>>below)&1: continue
        if z==1 or (occ>>(below-16)&1):
            out.append(below)
    return list(dict.fromkeys(out))

# -------------------------------------------------------------
# すでにある即勝ち/即負け判定を再利用
def my_threat_exists(my: int, opp: int) -> bool:
    return bool(collect_threats(my, opp))

def find_forced_block(state: State) -> int | None:
    """相手 1 手詰みを *唯一* 防げるセル idx を返す。
       ・1 手詰みが無い   → None
       ・2 箇所以上ある    → 防げない → None
    """
    opp_threats = collect_threats(state.enemy_pieces, state.pieces)
    if len(opp_threats) == 1:
        return opp_threats[0]
    return None                     # 0 or 2 以上

"""
# -------------------------------------------------------------
def tsumi(state: State, depth: int) -> int:
    my, opp = state.pieces, state.enemy_pieces

    # --- 1) いきなり自分の 1 手詰み ---
    if my_threat_exists(my, opp):
        return +1

    # --- 2) 相手の 1 手詰みがある？ ---
    block = find_forced_block(state)
    if block is not None:
        # 強制ブロックして相手番へ
        return -tsumi(state.next_from_index(block), 2)
    elif collect_threats(opp, my):      # 受けが複数 → 負け
        return -1

    # --- 3) 残り探索深さによる分岐 ---
    if depth == 2:
        # 「脅威を作れる手」を列挙
        cand_moves = (
            collect_pre_threats(my, opp) +
            collect_float_pre_threats(my, opp)
        )
        for mv in cand_moves:
            # こちらが mv を打ったあと、相手番で tsumi(1) が -1 なら OK
            if tsumi(state.next_from_index(mv), 1) == -1:
                return +1
        return 0                      # 見つからず → 引き分け
    else:  # depth == 1
        return 0                      # 打ち切りはドロー
"""
# --- キャッシュ用辞書 ---
# key = (my_bits, opp_bits, depth)
TSUMI_CACHE: dict[tuple[int,int,int], int] = {}

def tsumi(state: State, depth: int) -> int:
    """
    +1 : 現手番必勝
    -1 : 現手番必敗
     0 : 引き分け／未確定
    depth は {2,1}
    """
    my, opp = state.pieces, state.enemy_pieces
    key = (my, opp, depth)
    if key in TSUMI_CACHE:
        return TSUMI_CACHE[key]

    # --- 1) いきなり自分の即詰み ---
    # collect_threats は "今すぐ打てる三連→四目" のインデックスリスト
    if collect_threats(my, opp):
        TSUMI_CACHE[key] = +1
        return +1

    # --- 2) 相手の唯一受け手 ---
    block = find_forced_block(state)
    if block is not None:
        # この一手でしか防げない → 防いで深さ２で再帰
        res = -tsumi(state.next_from_index(block), 2)
        TSUMI_CACHE[key] = res
        return res
    # 相手に複数受け手があれば負け確
    if collect_threats(opp, my):
        TSUMI_CACHE[key] = -1
        return -1

    # --- 3) 深さによる分岐 ---
    if depth == 2:
        # 候補手を一度だけ列挙（重複排除）
        cands = set(collect_pre_threats(my, opp))
        cands |= set(collect_float_pre_threats(my, opp))
        if not cands:
            # 二連も浮き脅威も作れない → 引き分け扱い
            TSUMI_CACHE[key] = 0
            return 0

        # いずれかの一手で「次で相手が詰み失敗」なら勝ち
        for mv in cands:
            if tsumi(state.next_from_index(mv), 1) == -1:
                TSUMI_CACHE[key] = +1
                return +1

        TSUMI_CACHE[key] = 0
        return 0

    else:  # depth == 1
        # 深さ１はドロー打ち切り
        TSUMI_CACHE[key] = 0
        return 0



# 脅威連鎖--------------------------------------------------------------------
def local_tactics_value(state: State) -> tuple[bool, float]:
    # ---- ❶ 2-ply 読み (tsumi) -----------------
    v = tsumi(state, 2)
    if v != 0:
        return True, float(v)

    return False, 0.0          # まだ分からない

# --------------------------------------------------------------------
@dataclass
class State:
    pieces:        int = 0  # 現手番の石
    enemy_pieces:  int = 0  # 相手の石

    # --- 追加ここから -------------------------------------------------
    @property
    def my_bits(self) -> int:      # 自分石（現手番）
        return self.pieces

    @property
    def opp_bits(self) -> int:     # 相手石
        return self.enemy_pieces
    # --- 追加ここまで -------------------------------------------------

    # ---- 基本 ----
    @staticmethod
    def pop(bits:int)->int: return bits.bit_count()
    def turn(self)->int:    return self.pop(self.pieces|self.enemy_pieces)+1
    def is_first_player(self)->bool: return self.pop(self.pieces)==self.pop(self.enemy_pieces)

    # ---- 勝敗 ----
    def _is_win(self, bits:int)->bool:
        return any((bits & line)==line for line in LINES76)
    def is_win (self)->bool: return self._is_win(self.pieces)
    def is_lose(self)->bool: return self._is_win(self.enemy_pieces)
    def is_draw(self)->bool: return (self.pieces|self.enemy_pieces)==ALL_MASK
    def is_done (self)->bool: return self.is_win() or self.is_lose() or self.is_draw()

    # ---- 合法手（重力）----
    def legal_actions(self)->List[int]:
        acts, occ = [], self.pieces|self.enemy_pieces
        for x in range(SIZE):
            for y in range(SIZE):
                for z in range(SIZE):          # 下から探索
                    i = idx(x,y,z)
                    if not (occ>>i & 1):
                        acts.append(i); break
        return acts

    # ---- 手を打つ ----

    def next_from_index(self, i) -> "State":
        i = int(i)                     # ★ここを追加（numpy.int64 → int）
        assert not ((self.pieces | self.enemy_pieces) >> i & 1), "occupied"
        return State(self.enemy_pieces, self.pieces | (1 << i))


    def place(self, x:int, y:int)->"State":
        for z in range(SIZE):
            i = idx(x,y,z)
            if not ((self.pieces|self.enemy_pieces)>>i & 1):
                return self.next_from_index(i)
        raise ValueError("column full")

    # ---- 表示 ----
    def __str__(self)->str:
        ox = ('o','x') if self.is_first_player() else ('x','o')
        head = "   " + "   ".join(f"z={z}" for z in range(SIZE))
        rows=[head]
        for y in range(SIZE-1,-1,-1):
            line=[]
            for z in range(SIZE):
                s=[]
                for x in range(SIZE):
                    b=BIT(x,y,z)
                    s.append(ox[0] if self.pieces & b else
                             ox[1] if self.enemy_pieces & b else '-')
                line.append("".join(s))
            rows.append("   ".join(line))
        return "\n".join(rows)

    # ---- ライン評価 (+自分, -相手) ----
    def line_counts(self)->List[int]:
        out=[]
        for line in LINES76:
            if (self.pieces & line) and (self.enemy_pieces & line): out.append(0)
            elif self.pieces & line:  out.append(self.pop(self.pieces & line))
            else:                     out.append(-self.pop(self.enemy_pieces & line))
        return out

# ---------------- ランダム手 ----------------
def random_action(state: State) -> int:
    """合法手（セル index 0-63）の中から 1 手ランダムに返す"""
    return random.choice(state.legal_actions())

# ---------------- プレイアウト ----------------
def playout(state: State) -> int:
    """
      終局まで双方ランダムに打ち進め、
      先手視点で  win:+1 / draw:0 / lose:-1 を返す
    """
    while not state.is_done():
        state = state.next_from_index(random_action(state))
    return 1 if state.is_win() else -1 if state.is_lose() else 0

# ---------------- MCTS で行動選択 ----------------
def mcts_action(state: State, rollouts: int = 1000) -> int:
    """MCTS で bestMove を返す（戻り値はセル index）"""

    class Node:
        __slots__ = ("state", "w", "n", "children", "move")
        def __init__(self, state: State, move:int|None=None):
            self.state    = state   # 盤面
            self.move     = move
            self.w        = 0       # 累計価値
            self.n        = 0       # 試行回数
            self.children = None    # 子ノード list[Node] | None

        # ★ここを追加 ─────────────────────
        def _update(self, value: float) -> None:
            """バックプロパゲーション用の加算ラッパ"""
            self.w += value
            self.n += 1
        # ───────────────────────────────

        # -------- ノード評価 --------
        def evaluate(self) -> float:
            # 1) 終局なら価値を返す
            if self.state.is_done():
                value =  1 if self.state.is_win()  else \
                        -1 if self.state.is_lose() else 0
                self.w += value; self.n += 1
                return value

            # 2) ★ TSS フック ★
            solved, v = local_tactics_value(self.state)
            if solved:
                self._update(v)
                return v   # ここで終了 → プレイアウトしない

            # 2-a) 未展開ならプレイアウト
            if self.children is None:
                value = playout(self.state)
                self.w += value; self.n += 1
                if self.n == 10:                      # 展開閾値
                    self.expand()
                return value

            # 2-b) 展開済みなら UCB1 で子を選択
            value = -self.best_child().evaluate()
            self.w += value; self.n += 1
            return value

        # -------- 子展開 --------
        def expand(self):
            self.children = [
                Node(self.state.next_from_index(i), move=i)
                for i in self.state.legal_actions()
            ]

        # -------- UCB1 で子を選ぶ --------
        def best_child(self) -> "Node":
            # まず未訪問ノード優先
            for c in self.children:
                if c.n == 0:
                    return c

            total = sum(c.n for c in self.children)
            C     = 2.0                               # 探索定数
            ucb_values = [
                -c.w / c.n + C * math.sqrt(math.log(total) / c.n)
                for c in self.children
            ]
            return self.children[ucb_values.index(max(ucb_values))]

    # -------- MCTS 開始 --------
    root = Node(state)
    root.expand()

    for _ in range(rollouts):
        root.evaluate()

    # -------- 試行回数最大の手を選択 --------
    counts = [c.n for c in root.children]
    best_child = max(root.children, key=lambda c: c.n)
    return best_child.move
