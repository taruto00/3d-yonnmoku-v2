# -*- coding: utf-8 -*-
"""evaluate_best_player.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XI8cy1BUP0Jayeny0MpCK3h-pSP_Gq-c
"""

# =============================================================
# ベストプレイヤーの評価 ― ビットボード版
# =============================================================
from pathlib import Path
import numpy as np
from tensorflow.keras.models import load_model
from tensorflow.keras import backend as K

from game import State, random_action, mcts_action          # ビットボード State
from pv_mcts import pv_mcts_action                          # ビットボード対応版

EP_GAME_COUNT = 10        # 評価ゲーム数

# -------------------- 先手ポイント ---------------------------
def first_player_point(ended_state: State) -> float:
    if ended_state.is_lose():
        return 0.0 if ended_state.is_first_player() else 1.0
    return 0.5

# -------------------- 1 ゲーム実行 ---------------------------
def play(next_actions):
    state = State()
    while not state.is_done():
        action_fn = next_actions[0] if state.is_first_player() else next_actions[1]
        action    = action_fn(state)                 # セル index
        state     = state.next_from_index(action)    # ★ ビットボード用
    return first_player_point(state)
"""
# -------------------- 1 ゲーム実行 ---------------------------
def play(next_actions):
    state = State()
    while not state.is_done():
        action_fn = next_actions[0] if state.is_first_player() else next_actions[1]
        action    = action_fn(state)
        state     = state.next_from_index(action)
    # 勝敗の文字列も返す（Win / Lose / Draw）
    point = first_player_point(state)
    if point == 1.0:
        result = "Win"
    elif point == 0.0:
        result = "Lose"
    else:
        result = "Draw"
    return point, result
"""


# -------------------- 汎用評価関数 ---------------------------
def evaluate_algorithm_of(label, next_actions):
    total = 0.0
    for i in range(EP_GAME_COUNT):
        if i % 2 == 0:
            total += play(next_actions)              # 評価対象が先手
        else:
            total += 1.0 - play(next_actions[::-1])  # 後手に回す
        print(f"\rEvaluate {i+1}/{EP_GAME_COUNT}", end="")
    print()

    avg = total / EP_GAME_COUNT
    print(f"{label}  average point: {avg:.3f}")
"""
def evaluate_algorithm_of(label, next_actions):
    total = 0.0
    for i in range(EP_GAME_COUNT):
        if i % 2 == 0:
            point, result = play(next_actions)               # 評価対象が先手
        else:
            point, result = play(next_actions[::-1])         # 評価対象が後手
            point = 1.0 - point

        total += point
        print(f"Game {i+1:2d}/{EP_GAME_COUNT}: {result} (point={point:.1f})")

    avg = total / EP_GAME_COUNT
    print(f"\n{label}  average point: {avg:.3f}\n")
"""


# -------------------- ベストプレイヤー評価 --------------------
def evaluate_best_player():
    # best.h5 を推論専用でロード
    model = load_model("./model/best_v2.h5", compile=False)

    # ベスト AI (PV-MCTS) と他アルゴリズムの対戦
    best_ai   = pv_mcts_action(model, temperature=0.0, add_noise = False) # ノイズ無しを読み込む
    best_ai_num = pv_mcts_action(model, temperature=0.0, num_simulations=300, add_noise = False)

    # ① VS Random
    evaluate_algorithm_of("VS_Random", (best_ai, random_action))

    # ② VS MCTS (ノイズなし純粋 MCTS)
    evaluate_algorithm_of("VS_MCTS", (best_ai_num, mcts_action))

    # 後片付け
    K.clear_session()
    del model
